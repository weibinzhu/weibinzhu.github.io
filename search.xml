<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[几种方法实现自适应的有文字分割线]]></title>
    <url>%2F2018%2F01%2F11%2F%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E6%9C%89%E6%96%87%E5%AD%97%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[在写页面的时候我们经常需要写一些带文字的分割线。我们需要横线垂直居中，文字水平居中，并且横线的长度能根据文字长度自适应。类似这样：为此我参考了一些插件的做法，加上自己的一些思考，总结出以下三种写法： 使用table-cell以及背景图片（vux以及Cola-UI的写法）这个方法主要应用了table-cell的自适应特性，再配合使用background-position将北京图片居中。为了减少http请求，此处的图片采用base64。123&lt;div class="divider"&gt; 自适应小标题&lt;/div&gt; 12345678910111213141516171819202122.divider&#123; text-align: center; display: table; white-space: nowrap;/*不然文字会被挤成一行一个字*/ height: 50px; line-height: 50px; font-size: 16px; color:#353535; &#125; .divider:before,.divider:after&#123; content: ''; display: table-cell; width: 50%; /*设置50%是为了确保能自适应文字宽度，最小的时候也能占满一行，如果有文字就会挤开*/ background-repeat: no-repeat; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABaAAAAACCAYAAACuTHuKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1OThBRDY4OUNDMTYxMUU0OUE3NUVGOEJDMzMzMjE2NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1OThBRDY4QUNDMTYxMUU0OUE3NUVGOEJDMzMzMjE2NyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjU5OEFENjg3Q0MxNjExRTQ5QTc1RUY4QkMzMzMyMTY3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU5OEFENjg4Q0MxNjExRTQ5QTc1RUY4QkMzMzMyMTY3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+VU513gAAADVJREFUeNrs0DENACAQBDBIWLGBJQby/mUcJn5sJXQmOQMAAAAAAJqt+2prAAAAAACg2xdgANk6BEVuJgyMAAAAAElFTkSuQmCC); &#125; .divider:before&#123; background-position: right 1em top 50%; &#125; .divider:after&#123; background-position: left 1em top 50%; &#125; 使用flex-box这个方法主要是利用了flex-box中自动撑满空间的特性，以及align-items:center。优点是代码简洁优雅，缺点是兼容性稍差。12345&lt;div class="title"&gt; &lt;div class="line"&gt;&lt;/div&gt; &lt;div class="text"&gt;自适应标题&lt;/div&gt; &lt;div class="line"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334 .title&#123; display: flex; flex-direction: row; align-items: center; /*垂直居中*/ width:100%; &#125; .line&#123; flex:1; /*自动撑满剩余空间*/ border-top: 1px solid #353535; /*使用border制作横线*/ &#125; .text&#123; font-size: 16px; margin:0 10px; color:#353535; &#125;``` ### 利用table-cell的自动撑满特性以及vertical-align特性这个是我自己更具前两个方案总结出来的。其实实现这种分割线的要点在于实现自动撑满空间，以及垂直居中。恰好table-cell都能做到这两点。我提出的这个方法缺点是html结构有点复杂。```html&lt;div class="divider"&gt; &lt;div class="line-container"&gt; &lt;div class="line"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="text"&gt;自适应小标题&lt;/div&gt; &lt;div class="line-container"&gt; &lt;div class="line"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.divider&#123; display: table; font-size: 16px; color: #353535; height: 30px; line-height: 30px; width: 100%;&#125;.line-container&#123; display: table-cell; width: 50%; vertical-align: middle; /*让table-cell内部的元素垂直居中*/ padding: 0 10px;&#125;.line&#123; width: 100%; /*内部元素的长度撑满父元素即可*/ border-top: 1px solid #353535;/*跟之前一样用border实现横线*/ &#125;.text&#123; white-space: nowrap;/*跟之前一样避免文字被挤成一个字一行*/&#125; 以上就是我收集、提出的三种实现自适应文字分割线的方法，欢迎大家提出修改意见：）]]></content>
  </entry>
  <entry>
    <title><![CDATA[30分钟入门正则表达式]]></title>
    <url>%2F2017%2F08%2F03%2F15%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式既简单又博大精深。半个小时肯定是不能精通，不过入门应该是够了，接下来赶紧把它用到实际编程中，熟能生巧，多用就是走向精通的捷径。 什么是正则表达式？简单来说就是按照某种规则去匹配符合条件的字符串，正则表达式描述的就是这个规则。 相信大家都用过编辑器（如sublime）里的查找功能。你在搜索框输入几个字符，编辑器就会帮你找到含有这些字符的字符串。这里你输入那几个字符其实就是一种规则，编辑器找到的就是符合这个规则的字符串。只不过这样的查找规则过于简单，很多时候不能找出我们想要的东西。正则表达式的出现正是用来解决这个痛点的。通过他我们能够描述出精确得多的规则，也就更容易找到我们想要的东西。 正则表达式就像JSON一样，并不是某个语言独有的。 大部分编程语言都支持正则表达式，本文重点讲讲Javascript中的正则表达式。 在线可视化工具正则表达式的规则虽然简单，不过一长串字符还是很容易让人看晕的，debug也不方便。这里我推荐一个在线的可视化工具，他能够很形象地描述正则表达式。下面我简单说一下怎么看它给出的结果。 我随便写了一个正则表达式\b\d{3}.?\w+\d*\b。什么意思先不用管，我们直接看结果。 第一个word boundary就表示说这是一个单词的边界，digit就表示数字，这些都用英文写的很清楚了我就不细说了（也说不完）。重点看后面那些循环和分支。第一个digit那里可以看到有一个圈，他代表循环，2times表明循环两次，加上原本那个digit就是有三个digit。明显这里就是三个digit的简写。后面any character上面有一条空的分支，表明这里可以有一个任意字符，也可以没有。再后面一个digit有一个空分支，也有一个表示循环的圈，圈上没有写明次数，这里的意思是可以有一个digit，可以有多个（无上限），也可以一个也没有。 有没有觉得很形象？没有这感觉的话可能是因为你还没学正则的那些规则，没关系，学了规则之后再回来看，到时候你会发现这正是学习和debug的利器。 RegExp对象JS通过内置的RegExp对象支持正则表达式，跟其他JS对象一样，实例化RegExp对象也有两种方法： 字面量：var reg = /\bis\b/g;(g是修饰符，表示进行全文搜索匹配) 构造函数：var reg = new RegExp (&#39;\\bis\\b&#39; , &#39;g&#39; );(字符串中的\是有含义的字符，所以我们需要转义)（其他在后面被介绍的，有特殊含义的字符，当我们需要匹配他们的时候也需要用\转义） 元字符正则表达式由两种基本字符类型组成： 原义文本字符，例如’a’就是指字母’a’ 元字符，类似我们之前用过的\b。下面列举了一些元字符 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行 \r 回车 \0 空字符 \f 换页 \cX 与X对应的控制字符（ctrl+X） 还有一些具有特殊含义的标点符号也是元字符：* + ? $ ^ . | \ ( ) { } [ ]。 元字符当然不止这些，下面我们将结合他们的用法慢慢介绍。 字符类一般情况下正则表达式的一个字符对应字符串的一个字符，例如ab\t的含义就会一个字母a一个字母b再加一个水平制表符 有时候我们不是想匹配某个字符而是某一类字符，例如不只是a，而是a，b，c都行。这种情况下我们可以使用元字符[]来构建一个简单的类。所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。例如：表达式[abc]把字符a或b或c归为一类，意思是’a’,’b’,’c’都行。 取反有时候我们不是要匹配某些字符而是躲开某些字符。这时候我们可以用元字符^创建反向类。意思是不属于某类的内容，如[^abc]表示不是字符a或b或c的内容 范围类有时候我们需要匹配的那一类字符太多，比如说我们想匹配一个任意小写字母，傻乎乎地写上[abcdefg......]既麻烦又不简洁。这时候我们可以使用范围内。就像这样：[a-z]，这表明我们要匹配任意一个从a到z的字母。 有几点我们要注意的。 这是一个双闭区间，包含了a和z。 类的内部是可以连写的，例如可以这样：[a-zA-Z]，意思是匹配任意一个a到z或者A到Z的字母。 两个字符之间的短横线会被认为是在表示范围，如果我们就是想匹配短横线，我们可以把它加在后面，例如这样：[a-z-]，意思是任意一个a到z的字母或者短横线。 预定义类为了进一步简化我们的正则表达式，我们可以使用下面这些预定义类。 字符 等价类 含义 . [^\r\n] 除了回车符和换行符以外的所有字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\n\x)b\f\r] 任何空白字符，包括空格、制表符、换页符等等 \S [^\t\n\x)b\f\r] 非空白符 \w [a-zA-z_0-9] 包括下划线的任何单词字符 \W [^a-zA-z_0-9] 非单词字符 修饰符前面的例子用到一个修饰符g，除了g以外还有其他修饰符，他们的意思如下： 修饰符 含义 g 全局搜索，而不是搜索到第一个就停止 i 忽略大小写 m 多行搜索 （把换行符后的当新的一行） 使用这些修饰符的话就像上面说过的例子一样，如果是通过字面量实例化，就在最后的/后面加上修饰符，如果是通过构造函数，就作为第二个参数传递给构造函数。 定位符定位符能够使你的正则表达式匹配特定位置的字符。 字符 含义 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。（不是在中括号中就是边界的意思） $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 \b 单词边界。例如，’er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 非单词边界。与上面相反，’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 举个例子，有输入字符串&quot;12A1A&quot;，我们只想匹配开头的数字，不想匹配中间的。这时候我们可以用这样的正则表达式：^\d。 注意： 在用^匹配开头的时候应将^放在表达式开头，如^\d，而在用$匹配结尾的时候则需要放在表达式后面。 量词有时候我们想匹配多个相同的字符，例如匹配3个数字。我们当然不会这么写：\d\d\d，这时候我们就用到了量词。 字符 含义 ? 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 贪婪模式与非贪婪模式大家有没有想过，如果我们在用上面提到的量词时给出的量词时一个范围，例如\d{3,6}时，究竟会匹配到3到6次的哪一个呢？ 其实在这种情况下，正则表达式选择次数的时候会有两种模式： 贪婪模式 这是默认模式。 尽可能多的匹配。例如12345678.replace(\d{3-6},&#39;X&#39;)的结果为X78。虽然3,4,5次都符合，不过最终匹配的是6次。 非贪婪模式 让正则表达式尽可能少的匹配，也就是说一旦匹配成功不再继续尝试。 只需要在量词后加上?。 同样举上面的例子12345678.replace(\d{3-6}？,&#39;X&#39;)此时的结果为XX78。123和456都被匹配到了。 分组与反向引用首先思考一个例子，假如我们想把形如2017-8-3这样的日期修改成8/3/2017这样的日期，那么需要怎么做呢？本节讲到的分组与反向引用可以帮组你。 使用（ ） 可以达到分组的功能，使量词作用于分组。例如(hello){3}表示hello重复三遍。 使用|，可以达到或的效果。他会把表达式分成前后两部分，两部分任意一个匹配成功都行。有时候我们并不想把整个表达式分成两部分，只想其中一段分成两部分。这时候我们可以利用分组。WEf(on|ca)serr 意思是中间是on或者ca都行。 反向引用。使用 $ 能够捕获分组的内容（类似变量的概念）。$1表示的就是第一个分组，以此类推可以表示第n个分组。举个例子：12'2016-2-14'.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g, '$2/$3/$1')// 结果被替换为2/14/2016 忽略分组。有时候我们不想捕获某些分组，只需要在这个分组内加上?:就可以了。例如(?:hello).(world)这样hello这个分组就不会被捕获，此时world算第一个分组。 前瞻与后顾首先说明一下什么叫『前』什么『后』。 正则表达式从文本头部向尾部开始解析，因此文本尾部的方向就叫做『前』。 前瞻就是正则表达式在匹配到规则时，向前检查是否符合断言。后顾就是把反向换过来。 这里所说的断言其实用来限定匹配字符但又不属于匹配字符的东西。举个例子，我们要匹配一个跟在一个字母后面的数字，这里这个『跟在一个字母后面』就是断言。 JS不支持后顾符合和不符合断言称为肯定（正向）匹配和否定（负向）匹配。 名称 正则 备注 正向前瞻 exp(?=assert) exp表示规则，assert表示断言。后同 负向前瞻 exp(?!assert) 正向后顾 exp(?&lt;=assert) JS不支持 负向后顾 exp(?&lt;!assert) JS不支持 举个例子：12'a2*34vv'.replace(/\w(?=\d)/g, 'X')// 结果为X2*X4VV 表明只有a和3符合要求，注意正则表达式中，括号内的部分仅为断言，所以不会被替换。 JS正则表达式对象（RegExp）前面说过虽然很多编程语言都支持正则表达式，不过这里主要讲的是Javascript下的。因此我们在这节讲讲JS内建的RegExp对象。 对象属性 属性 类型 含义 默认值 global 布尔值 是否全文搜索 false ignoreCase 布尔值 是否忽略大小写 false multiline 布尔值 是否多好检索 false source 字符串 正则表达式的文本 lastIndex 整数 若匹配模式中含有g,这个属性储存整个字符串中下一次检索的开始位置 0 注意这些属性时只读的。 对象方法 RegExp.prototype.test(str) 测试一下在给定字符串中能否匹配到，能就返回true。 如果正则表达式有修饰符g，即全局搜索。那么每一次调用test方法，都会从上一次的lastIndex开始搜索，直到匹配不到返回false才从头开始。例如有字符串’12cd’,正则表达式是/\d/。第一次调用test方法返回true，lastIndex为1，第二次调用返回true，lastIndex为2，第三次调用返回false，lastIndex重置为0，第四次调用返回true，lastIndex又变回1。 鉴于有这样的特性，我们建议在使用这个方法时要回归他的本意，即测试某字符串能否匹配到你想要的东西，知道有没有就行了，不关心有多少个在哪里等信息（一定要这些信息的话就改用下面说到的方法）。 因此使用这个方法时不要给正则表达式加上修饰符g。 RegExp.prototype.exec(str) 使用正则表达式对字符串执行搜索，并将跟新全局RegExp对象的属性以反映匹配结果。 如果没有匹配的文本就返回null，否则返回一个结果数组。 index声明匹配文本的第一个字符的位置。 input存放被检索的字符串string。 非全局调用情况 代用非全局RegExp的exec（）时，返回数组。 第一个元素是与正则表达式相匹配的文本。 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有）。 第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有），以此类推。 看例子： 123456789101112131415161718192021var reg3 = /\d(\w)(\w)\d/;var reg4 = /\d(\w)(\w)\d/g; // 全局var ts = '$1az2bb3cy4dd5ee'; // 测试用字符串var ret3 = reg3.exec(ts);console.log(reg3.lastIndex + '\t' + ret.index + 't' + ret.toString());console.log(reg3.lastIndex + '\t' + ret.index + 't' + ret.toString()); // 执行两次// 结果为：// '0 1 1az2,a,z'// '0 1 1az2,a,z'// 两次结果一样while(ret4 = reg4.exec(ts))&#123; console.log(reg4.lastIndex + '\t' + ret.index + '\t' + ret.toString());&#125;// 结果为：// '5 1 1az2,a,z'// '11 7 3cy4,c,y'// 两次结果不一样 字符串对象有关正则表达式的方法JS中的字符串对象其实也支持正则表达式，下面是这个对象有关正则表达式的一些方法。 String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 返回第一个匹配结果的index，找不到返回-1. search()方法不执行全局匹配，会忽略修饰符g，并且总从字符串的开始进行检索 String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与regexp匹配的文本 regexp有无修饰符g对结果影响很大。 非全局调用 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素以外，返回的数组还含有2个对象属性 index声明匹配文本的原始字符正字字符串中的位置 input声明对stringObject的引用 看一个例子1234567891011var reg3 = /\d(\w)\d/;var reg4 = /\d(\w)\d/g; // 全局var ts = '$1a2b3c4d5e'; // 测试用字符串var ret = ts.match(reg3);console.log(ret);console.log(ret.index + '\t' + reg3.lastIndex);// ["1a2", "a"]// "1 0"// 表明不会影响正则表达式的lastIndex属性 全局调用 如果regexp具有g，则match()方法将执行全局搜索，找到字符串中的所有匹配子字符串 如果没有找到，返回null 如果找到一个多多个，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或者input属性 看一个例子12345678910var reg3 = /\d(\w)\d/;var reg4 = /\d(\w)\d/g; // 全局var ts = '$1a2b3c4d5e'; // 测试用字符串ret = ts.match(reg4);console.log(ret);console.log(ret.index + '\t' + reg4.lastIndex);// ["1a2", "3c4"]// "undefined 0" String.prototype.split(reg) 一般用法&#39;a,b,c,d&#39;.split(&#39;,&#39;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 除此之外我们还可以传入正则表达式实现复杂点的分割：&#39;a1b1c2d&#39;.split(/\d/); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function会在每次匹配替换时调用，有四个参数： 匹配字符串 正则表达式分组内容（如果没有分组则没有这个参数） 匹配项在字符串中的index 原字符串 Referencehttp://blog.guowenfh.com/2015/12/01/Regexp-basis/ http://www.runoob.com/regexp/regexp-tutorial.html http://www.jb51.net/tools/zhengze.html http://www.imooc.com/learn/706]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用rem进行移动端适配]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%88%A9%E7%94%A8rem%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[之前面试的时候被问到移动端适配用什么单位，答不出来，遂搜集了一些资料总结成这篇文章。水平有限，虽然已经尽可能地保证不出错，但难免有这样或那样的漏洞，如果你发现任何问题，请给我留言。感恩。 什么是rem？一般来说我们听到更多的是em，而rem则是root em的意思。顾名思义，rem是指相对于根元素字体大小的单位，而这个根元素，一般指的就是html。例如，若html的font size为16px, 则1rem=16px。 兼容性目前PC端的Chrome（4+），Firefox（3.6+），Safari（5+），以及IE（11+）均支持rem，移动端的主流浏览器，包括UC，QQ浏览器，三星内置浏览器也都支持rem。可以说只要不用支持古老的浏览器，如IE8、初代iPhone的Safari，都可以放心地使用rem。 优点在说rem的优点之前我们先来回顾一下移动端适配的一般做法。 流式布局，宽度使用百分比定义，高度和文字大小用px固定。缺点是不同屏幕尺寸下显示效果会有差异，在大屏幕手机下甚至会因为元素宽度被过度拉伸导致显示效果不协调。因此仅适用于一些比较简单的页面。 固定宽度，给页面设置固定宽度，超出部分留白。很明显，这种粗暴的方法对大屏手机很不友好。 弹性盒子布局。 响应式布局，其实就是针对几个主流设置对应的CSS，再利用媒体查询（Media Queries）来确定需要显示的样式。当然这样要求我们写额外的样式，提高了工作量，同时由于不可能为所有屏幕尺寸写针对性的样式，因此只能在若干主流的屏幕尺寸下做到完美显示。 我们发现这些方法要么不能在不同设备上完美显示，要么就是过于复杂，而rem却能很好的兼顾简单和兼容性。 之前提到rem是相对于根元素字体大小的单位，如果根元素的font size是16px，那么1rem就是16px，如果根元素是37.5px，那么1rem就是37.5px。可见，如果页面元素都用rem来设置大小，那么我们只需要修改根元素的font size就能等比例地缩放整个页面。也就是说只要根据不同屏幕尺寸设置根元素font size，我们就能等比例适配所有屏幕，是不是很优雅？ 用法说了那么多我们来看看究竟要怎么使用吧。先看一个例子。 Demo1&lt;div class="btn"&gt;button&lt;/div&gt; 123456789101112html&#123; font-size:40px;&#125;.btn&#123; width: 2rem; height: 0.5rem; font-size: 0.5rem; line-height: 0.5rem; text-align:center; background-color:red; &#125; 例子中div的单位都是rem，留意宽高，可以看到宽高分别是80px和10px，而这正分别等于 2*40px和0.5*40px。这表明宽高是通过根元素html的font-size计算出来的，此时1rem=40px。 此时我们把html的font-size修改成原来的两倍即80px，其他不作改动，结果如下图所示。显然div的宽高也变成了原来的两倍，此时1rem=80px。这也印证了之前所说的只需通过修改根元素的font-size值就可以等比例缩放。 相信到这里大家也发现，每次设置rem都要换算一遍，非常麻烦。为了方便我们可以： 将根元素的font-size设置成100px，这样只需要将px的数字的小数点往前挪两位再把单位换成rem就可以了，例如160px换成rem就是1.6rem。 利用sass，less等css预处理语言，设置一个函数专门用于单位转换。由于各种语言实现有区别，这里就不给出例子了。 利用现成的转换工具，这里推荐一个在线转换工具: px–&gt;rem 这篇文章的主题是移动端适配，现在就具体讲讲在实际运用中如何用rem适配不同大小的屏幕 一般来说我们拿到的设计稿都是以iphone6的屏幕为基准设计的，也就是说宽度为375px，假设我们把根元素的font-size设置为100px。如果我们要适配的屏幕宽度为320px（即iphone5的屏幕宽度），那么此时根元素font-size应该设置为：100*（320/375），即85.3px。通过这样设置我们的页面便能完美等比例适配320px的屏幕。 为了计算方便，也为了避免根元素的font-size太大我们一般把根元素font-size设置为屏幕宽度的1/10（即375px的屏幕就设置为37.5px，320px的屏幕就设置为32px）。这样我们无需经过计算就能直接根据需要适配的屏幕宽度来得出font-size的大小，同时也能避免根元素font-size太大。 现在问题来了，学挖掘机哪家强 究竟怎么动态修改font-size呢？有一个简单粗暴地方法，既然主流的屏幕分辨率也就那几个，我们大可以通过media query媒体查询，把最常见的几种情况写下来。1234567891011121314html &#123; font-size : 37.5px;&#125;@media only screen and (min-width: 320px)&#123; html &#123; font-size: 32px !important; &#125;&#125;@media only screen and (min-width: 414px)&#123; html &#123; font-size: 41.4px !important; &#125;&#125;&#125; 这样基本能覆盖大部分设备了，如果说一定要适配所有设备，我们还可以通过JS动态计算font-size。淘宝的首页就是用这个方法，审查元素之后可以看到不断改变屏幕大小，html的font-size都能实时变化。1document.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px'; 我们把上面的代码绑定到DOMContentLoaded时间中，这样在进入页面的时候就能马上计算出font-size。 参考资料： http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/ http://caibaojian.com/toutiao/6215 https://isux.tencent.com/web-app-rem.html]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2F2017%2F07%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello World!This is Weibin’s first artical.]]></content>
  </entry>
</search>